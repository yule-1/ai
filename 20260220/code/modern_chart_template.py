"""
Modern chart template for quick financial comparisons.

Usage example:
    python3 chart_template.py \
      --tickers 005930.KS,000660.KS,440110.KQ \
      --labels 삼성전자,SK하이닉스,파두 \
      --period 2y \
      --title "삼성전자 vs SK하이닉스 vs 파두 (Index=100)" \
      --out output/sample
"""

import argparse
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from matplotlib import font_manager, rcParams


# ---------- Style preset (modern/minimal) ----------
BG = "#0f1117"
PANEL = "#151823"
GRID = "#2a3040"
TXT = "#e8ecf3"
SUBTXT = "#9aa4b2"
ACCENTS = ["#7C83FD", "#00C2A8", "#FF7A59", "#F6C90E", "#A66CFF", "#37B4FF"]


def setup_korean_font():
    """Use an available Korean font (macOS-first) to avoid garbled labels."""
    candidates = [
        "Apple SD Gothic Neo",
        "Pretendard",
        "NanumGothic",
        "Noto Sans CJK KR",
        "Malgun Gothic",
    ]
    available = {f.name for f in font_manager.fontManager.ttflist}
    for name in candidates:
        if name in available:
            rcParams["font.family"] = name
            break
    rcParams["axes.unicode_minus"] = False


def load_close(ticker: str, period: str):
    df = yf.download(ticker, period=period, auto_adjust=False, progress=False)
    if df.empty:
        return None
    if isinstance(df.columns, pd.MultiIndex):
        return df[("Close", ticker)]
    return df["Close"]


def build_indexed_df(tickers, labels, period):
    series = {}
    for t, lbl in zip(tickers, labels):
        s = load_close(t, period)
        if s is not None and not s.empty:
            series[lbl] = s

    if not series:
        raise RuntimeError("No valid series downloaded.")

    prices = pd.concat(series.values(), axis=1)
    prices.columns = list(series.keys())
    prices = prices.dropna()
    indexed = prices / prices.iloc[0] * 100
    return indexed


def render(indexed: pd.DataFrame, title: str, out_base: Path):
    out_base.parent.mkdir(parents=True, exist_ok=True)

    fig = plt.figure(figsize=(12.8, 7.2), facecolor=BG)
    ax = plt.gca()
    ax.set_facecolor(PANEL)

    for i, col in enumerate(indexed.columns):
        ax.plot(
            indexed.index,
            indexed[col],
            label=col,
            linewidth=2.6,
            color=ACCENTS[i % len(ACCENTS)],
            solid_capstyle="round",
        )

    # baseline 100
    ax.axhline(100, color="#8b95a7", linestyle="--", linewidth=1.1, alpha=0.5)

    # cosmetics
    ax.grid(True, color=GRID, alpha=0.55, linewidth=0.8)
    ax.tick_params(colors=SUBTXT, labelsize=10)
    for spine in ax.spines.values():
        spine.set_color(GRID)

    ax.set_title(title, color=TXT, fontsize=16, fontweight="bold", pad=14)
    ax.set_ylabel("Indexed Price (Base = 100)", color=SUBTXT, fontsize=11)

    lg = ax.legend(
        facecolor=PANEL,
        edgecolor=GRID,
        labelcolor=TXT,
        fontsize=10,
        loc="upper left",
    )
    for t in lg.get_texts():
        t.set_color(TXT)

    # footer text
    fig.text(
        0.99,
        0.01,
        "Generated by Clnyang chart template",
        ha="right",
        va="bottom",
        color=SUBTXT,
        fontsize=9,
    )

    fig.tight_layout(rect=[0.02, 0.03, 0.98, 0.97])

    png_path = out_base.with_suffix(".png")
    csv_path = out_base.with_suffix(".csv")
    indexed.to_csv(csv_path, encoding="utf-8-sig")
    plt.savefig(png_path, dpi=180, facecolor=BG)
    plt.close(fig)
    return png_path, csv_path


def main():
    setup_korean_font()
    p = argparse.ArgumentParser()
    p.add_argument("--tickers", required=True, help="Comma separated tickers")
    p.add_argument("--labels", required=True, help="Comma separated labels")
    p.add_argument("--period", default="2y", help="e.g. 6mo,1y,2y,5y")
    p.add_argument("--title", required=True)
    p.add_argument("--out", required=True, help="Output base path without extension")
    args = p.parse_args()

    tickers = [x.strip() for x in args.tickers.split(",") if x.strip()]
    labels = [x.strip() for x in args.labels.split(",") if x.strip()]

    if len(tickers) != len(labels):
        raise ValueError("tickers and labels count must match")

    indexed = build_indexed_df(tickers, labels, args.period)
    png, csv = render(indexed, args.title, Path(args.out))
    print(f"PNG: {png}")
    print(f"CSV: {csv}")
    print(f"Rows: {len(indexed)}  Range: {indexed.index.min().date()} -> {indexed.index.max().date()}")


if __name__ == "__main__":
    main()
